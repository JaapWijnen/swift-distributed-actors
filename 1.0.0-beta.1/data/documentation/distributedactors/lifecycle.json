{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Monitoring distributed actor lifecycles enables you to react to their termination, regardless if they are hosted on the same, or on a remote host."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is crucial for building robust actor systems which are able to automatically remote e.g. remote worker references as they are confirmed to have terminated."},{"type":"text","text":" "},{"type":"text","text":"This can happen if the remote actor is just deinitialized, or if the remote host is determined to be "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MemberStatus\/down"},{"type":"text","text":"."}]},{"anchor":"Lifecycle-Watch","level":2,"type":"heading","text":"Lifecycle Watch"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A distributed actor is able to monitor other distributed actors by making use of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/LifecycleWatch"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a feature of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterSystem"},{"type":"text","text":" which allows us to monitor other actors, regardless of their location, in the cluster for termination."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, we can re-create the classic theater moment of Romeo and Juliet watching eachother, and acting as they realize the other (actor) has terminated:"}]},{"type":"codeListing","syntax":"swift","code":["distributed actor Romeo: LifecycleWatch {","    deinit {","        print(\"\\(Self.self) terminated!\")","    }","","    distributed func watch(_ romeo: Romeo) {","        watchTermination(of: romeo) { terminatedID in","            probe.tell(\"Oh no! \\(terminatedID) is dead!\")","            \/\/ TODO: Drink poison","        }","    }","}","","distributed actor Juliet: LifecycleWatch {","    deinit {","        print(\"\\(Self.self) terminated!\")","    }","","    distributed func watch(_ romeo: Romeo) {","        watchTermination(of: romeo) { terminatedID in","            probe.tell(\"Oh no! \\(terminatedID) is dead!\")","            \/\/ TODO: Stab through heart","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/LifecycleWatch\/watchTermination(of:whenTerminated:file:line:)"},{"type":"text","text":" API purposefully does not use async\/await because that would cause "},{"type":"codeVoice","code":"romeo"},{"type":"text","text":" to be retained as this function suspends. Instead, we allow it to complete and once the romeo actor is determined terminated, we get called back with its "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ActorID"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This API offers the same semantics, regardless where the actors are located, and always triggers the termination closure as the watched actor is considered to have terminated."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In case the watched actor is "},{"type":"emphasis","inlineContent":[{"type":"text","text":"local"}]},{"type":"text","text":", it’s termination is tied to Swift’s ref-counting mechanisms, and an actor is terminated as soon as there are no more strong references to it in a system. It then is deinitialized, and the actor system’s "},{"type":"codeVoice","code":"resignID(actor.id)"},{"type":"text","text":" is triggered, causing propagation to all the other actors which have been watching that actor."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In case the watched actor is "},{"type":"emphasis","inlineContent":[{"type":"text","text":"remote"}]},{"type":"text","text":", termination may happen because of two reasons:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"either its reference count "},{"type":"emphasis","inlineContent":[{"type":"text","text":"on the remote system"}]},{"type":"text","text":" dropped to zero and it followed the same deinitialization steps as just described in the local case;"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"or, the entire node the distributed actor was located on has been declared "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MemberStatus\/down"},{"type":"text","text":" and therefore the actor is assumed terminated (regardless if it really has deinitialized or not)."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The second remote case is illustrated by the following diagram:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"remote_watch_terminated.png"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This remote watch mechanism is how most of the cluster systems’ dynamic balancing and sharding mechanisms are implemented."}]},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Lifecycle watch “terminated” messages are "},{"type":"emphasis","inlineContent":[{"type":"text","text":"guaranteed"}]},{"type":"text","text":" to be delivered and processed by remote peers, even in face of message-loss. The cluster system takes re-delivery steps for such important system messages, such that one can rely on termination to always be delivered reliably."}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/distributedactors\/lifecycle"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Lifecycle","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Monitoring distributed actor lifecycles regardless of their location."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Lifecycle Monitoring","role":"article","modules":[{"name":"DistributedActors"}]},"hierarchy":{"paths":[["doc:\/\/DistributedActors\/documentation\/DistributedActors"]]},"seeAlsoSections":[{"title":"Articles","identifiers":["doc:\/\/DistributedActors\/documentation\/DistributedActors\/Introduction","doc:\/\/DistributedActors\/documentation\/DistributedActors\/Clustering","doc:\/\/DistributedActors\/documentation\/DistributedActors\/Observability"],"generated":true}],"references":{"doc://DistributedActors/documentation/DistributedActors/ClusterSystem/ActorID":{"role":"symbol","title":"ClusterSystem.ActorID","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActorID"}],"abstract":[{"type":"text","text":"Uniquely identifies a DistributedActor within the cluster."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterSystem\/ActorID","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActorID"}],"url":"\/documentation\/distributedactors\/clustersystem\/actorid"},"doc://DistributedActors/documentation/DistributedActors/ClusterSystem":{"role":"symbol","title":"ClusterSystem","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ClusterSystem"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ClusterSystem"},{"type":"text","text":" is a confined space which runs and manages Actors."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterSystem","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ClusterSystem"}],"url":"\/documentation\/distributedactors\/clustersystem"},"doc://DistributedActors/documentation/DistributedActors/LifecycleWatch":{"role":"symbol","title":"LifecycleWatch","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"LifecycleWatch"}],"abstract":[{"type":"text","text":"Provides a distributed actor with the ability to “watch” other actors lifecycles."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/LifecycleWatch","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LifecycleWatch"}],"url":"\/documentation\/distributedactors\/lifecyclewatch"},"doc://DistributedActors/documentation/DistributedActors/Introduction":{"role":"article","title":"Introducing Distributed Actors","abstract":[{"type":"text","text":"A high-level introduction to distributed actor systems."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Introduction","kind":"article","type":"topic","url":"\/documentation\/distributedactors\/introduction"},"doc://DistributedActors/documentation/DistributedActors/LifecycleWatch/watchTermination(of:whenTerminated:file:line:)":{"role":"symbol","title":"watchTermination(of:whenTerminated:file:line:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"watchTermination"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Watchee"},{"kind":"text","text":">("},{"kind":"externalParam","text":"of"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Watchee"},{"kind":"text","text":", "},{"kind":"externalParam","text":"whenTerminated"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"ID"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":", "},{"kind":"externalParam","text":"file"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":", "},{"kind":"externalParam","text":"line"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UInt","preciseIdentifier":"s:Su"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Watchee"}],"abstract":[{"type":"text","text":"Watch the "},{"type":"codeVoice","code":"watchee"},{"type":"text","text":" actor for termination, and trigger the "},{"type":"codeVoice","code":"whenTerminated"},{"type":"text","text":" callback when"}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/LifecycleWatch\/watchTermination(of:whenTerminated:file:line:)","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/lifecyclewatch\/watchtermination(of:whenterminated:file:line:)"},"remote_watch_terminated.png":{"alt":"Diagram showing two nodes in a cluster, and a terminated signal being issued as the remote (watched) node crashes and is declared as ‘down’.","type":"image","identifier":"remote_watch_terminated.png","variants":[{"url":"\/images\/remote_watch_terminated.png","traits":["1x","light"]}]},"doc://DistributedActors/documentation/DistributedActors/ActorID":{"role":"symbol","title":"ActorID","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActorID"}],"abstract":[{"type":"text","text":"Convenience alias for "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterSystem\/ActorID"},{"type":"text","text":"."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ActorID","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActorID"}],"url":"\/documentation\/distributedactors\/actorid"},"doc://DistributedActors/documentation/DistributedActors":{"role":"collection","title":"DistributedActors","abstract":[{"type":"text","text":"A peer-to-peer cluster actor system implementation for Swift."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors"},"doc://DistributedActors/documentation/DistributedActors/Clustering":{"role":"article","title":"Clustering","abstract":[{"type":"text","text":"Clustering multiple actor system instances into a single Distributed Actor System."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Clustering","kind":"article","type":"topic","url":"\/documentation\/distributedactors\/clustering"},"doc://DistributedActors/documentation/DistributedActors/Cluster/MemberStatus/down":{"role":"symbol","title":"Cluster.MemberStatus.down","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"down"}],"abstract":[{"type":"text","text":"Describes a member believed to be “down”, either by announcement by the member itself, another member,"},{"type":"text","text":" "},{"type":"text","text":"a human operator, or an automatic failure detector. It is important to note that it is not a 100% guarantee"},{"type":"text","text":" "},{"type":"text","text":"that the member\/node process really is not running anymore, as detecting this with full confidence is not possible"},{"type":"text","text":" "},{"type":"text","text":"in distributed systems. It can be said however, that with as much confidence as the failure detector, or whichever"},{"type":"text","text":" "},{"type":"text","text":"mechanism triggered the "},{"type":"codeVoice","code":".down"},{"type":"text","text":" that node may indeed be down, or perhaps unresponsive (or too-slow to respond)"},{"type":"text","text":" "},{"type":"text","text":"that it shall be assumed as-if dead anyway."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MemberStatus\/down","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/cluster\/memberstatus\/down"},"doc://DistributedActors/documentation/DistributedActors/Observability":{"role":"article","title":"Observability","abstract":[{"type":"text","text":"The cluster system offers a number of built-in observability capabilities about the state of the cluster, as well as distributed actors it manages."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Observability","kind":"article","type":"topic","url":"\/documentation\/distributedactors\/observability"}}}