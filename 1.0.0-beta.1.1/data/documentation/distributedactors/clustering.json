{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this article, we’ll learn how to configure and use multiple "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterSystem"},{"type":"text","text":" instances to form a distributed system."}]},{"anchor":"Initializing-a-ClusterSystem","level":2,"type":"heading","text":"Initializing a ClusterSystem"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this section, we will discuss initializing and using a distributed cluster system."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, import the "},{"type":"codeVoice","code":"Distributed"},{"type":"text","text":" module to enable the capability to declare "},{"type":"codeVoice","code":"distributed actor"},{"type":"text","text":" types,"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"DistributedActors"},{"type":"text","text":" module which is the main module of the cluster library which contains the "},{"type":"codeVoice","code":"ClusterSystem"},{"type":"text","text":" types."}]},{"type":"codeListing","syntax":"swift","code":["import Distributed","import DistributedActors"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, the first thing you need to do in your clustered applications is to create a "},{"type":"codeVoice","code":"ClusterSystem"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"You can use the default "},{"type":"codeVoice","code":"ClusterSystem()"},{"type":"text","text":" initializer which defaults to a "},{"type":"codeVoice","code":"\"ClusterSystem\""},{"type":"text","text":" system name and the default "},{"type":"codeVoice","code":"127.0.0.1:7337"},{"type":"text","text":" host\/port:"}]},{"type":"codeListing","syntax":"swift","code":["let system = await ClusterSystem() \/\/ default 127.0.0.1:7337 bound actor system```"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more realistic uses, it is expected that you will configure your cluster system as you start it up, so here is how a typical "},{"type":"codeVoice","code":"Main"},{"type":"text","text":" struct of an server-side application might look like:"}]},{"type":"codeListing","syntax":"swift","code":["@main","struct Main {","    static func main() async throws {","        let system = await ClusterSystem(\"FirstSystem\") { settings in","            settings.node.host = \"127.0.0.1\"","            settings.node.port = 7337","        }","        ","        try await system.terminated","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"try await system.terminated"},{"type":"text","text":" will suspend the "},{"type":"codeVoice","code":"main()"},{"type":"text","text":" function until the cluster is shut down, by calling "},{"type":"codeVoice","code":"shutdown()"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Declaring a distributed actor is similar to declaring a plain "},{"type":"codeVoice","code":"actor"},{"type":"text","text":". We do this by prepending the actor declaration"}]},{"anchor":"Configuring-TLS","level":3,"type":"heading","text":"Configuring TLS"},{"type":"paragraph","inlineContent":[{"type":"text","text":"TODO: documentation of TLS config"}]},{"anchor":"Forming-clusters","level":2,"type":"heading","text":"Forming clusters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Forming a cluster is the first step towards making use of distributed clusters across multiple nodes."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once a node joins at least one other node of an already established cluster, it will receive information about all other nodes"},{"type":"text","text":" "},{"type":"text","text":"which participate in this cluster. This is why often it is not necessary to give all nodes the information about all other nodes in a cluster,"},{"type":"text","text":" "},{"type":"text","text":"but only attempt to join one or a few o them. The first join “wins” and the cluster welcome the new node into the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership"},{"type":"text","text":"."}]},{"anchor":"Joining-existing-nodes","level":3,"type":"heading","text":"Joining existing nodes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the simplest scenario we already about some existing node that we can join to form a cluster, or become part of a cluster that node already is in."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is done using the system’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterControl"},{"type":"text","text":" object, like this:"}]},{"type":"codeListing","syntax":"swift","code":["system.cluster.join(node: Node(systemName: \"JoiningExample\", host: \"127.0.0.1\", port: 8228))"]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The difference between a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Node"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/UniqueNode"},{"type":"text","text":" is that a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Node"},{"type":"text","text":" is “some node on that address”, while"},{"type":"text","text":" "},{"type":"text","text":"an "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/UniqueNode"},{"type":"text","text":" is a node that we have contacted and know its exact unique node identifier. Therefore, when reaching"},{"type":"text","text":" "},{"type":"text","text":"out to a node we know nothing about just yet, we use the "},{"type":"codeVoice","code":"Node"},{"type":"text","text":" type."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can observe "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors"},{"type":"text","text":" in order to see when a node has been successfully joined."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"TODO:"}]},{"type":"text","text":" Pending addition of an async\/await based API to await joining the cluster successfully. "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-distributed-actors\/issues\/948"}]}]},{"anchor":"Automatic-Node-Discovery","level":3,"type":"heading","text":"Automatic Node Discovery"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The cluster system uses "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-service-discovery"},{"type":"text","text":" to discover nearby nodes it can connect to. This discovery step is only necessary to find IPs and ports on which we are expecting other cluster actor system instances to be running, the actual joining of the nodes is performed by the cluster itself. It can negotiate, and authenticate the other peer before establishing a connection with it (see also TODO: SECURITY)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The cluster is able to use any node discovery mechanism that implements the "},{"type":"codeVoice","code":"ServiceDiscovery"},{"type":"text","text":" protocol that has an implementation of the "},{"type":"codeVoice","code":"ServiceDiscovery"},{"type":"text","text":" protocol. like for example: "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/tuplestream\/swift-k8s-service-discovery"},{"type":"text","text":" which implements discovery using the kubernetes (k8s) APIs:"}]},{"type":"codeListing","syntax":"swift","code":["import ServiceDiscovery","import K8sServiceDiscovery \/\/ See: tuplestream\/swift-k8s-service-discovery","import DistributedActors","","ClusterSystem(\"Compile\") { settings in","    let discovery = K8sServiceDiscovery() ","    let target = K8sObject(labelSelector: [\"name\": \"actor-cluster\"], namespace: \"actor-cluster\")","    ","    settings.discovery = ServiceDiscoverySettings(discovery, service: target)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similarly, you can implement the "},{"overridingTitleInlineContent":[{"type":"text","text":"ServiceDiscovery"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-service-discovery","overridingTitle":"ServiceDiscovery"},{"type":"text","text":" protocol using any underlying technology you want,"},{"type":"text","text":" "},{"type":"text","text":"and this will then enable the cluster to locate nodes to contact and join automatically. It also benefits all other uses of service discovery in such new environment,"},{"type":"text","text":" "},{"type":"text","text":"so we encourage publishing your implementations if you’re able to!"}]},{"anchor":"Cluster-events","level":2,"type":"heading","text":"Cluster events"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Cluster events are events emitted by the cluster as changes happen to the lifecycle of members of the cluster."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generally, one should not need to rely on the low-level clustering events emitted by the cluster and focus directly on "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Lifecycle"},{"type":"text","text":" which expresses cluster lifecycle events in terms of emitting signals about an actor’s termination. E.g. when a node an actor was known to be living on is declared as "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MemberStatus\/down"},{"type":"text","text":" “terminated” signals are generated for all actors watching this actor. This way, you don’t usually have to think about specific nodes of a cluster, but rather focus only on the specific actor’s lifecycles you care about and want to be notified about their termination."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Having that said, some actors (or other parts of your program) may be interested in the raw event stream offered by the cluster system. For example, one can implement a stability report by observing how frequently "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/ReachabilityChange"},{"type":"text","text":" events are emitted, or take it one level further and implement your own "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/DowningStrategy"},{"type":"text","text":" based on observing those reachability changes."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Events emitted by the cluster, are always expressed in terms of cluster "},{"type":"emphasis","inlineContent":[{"type":"text","text":"members"}]},{"type":"text","text":" ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Member"},{"type":"text","text":"), which represent some concrete "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/UniqueNode"},{"type":"text","text":" which is part of the membership. As soon as a node becomes part of the membership, even while it is only "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MemberStatus\/joining"},{"type":"text","text":", events about it will be emitted by the cluster."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A cluster member goes through the following phases in its lifecycle:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"cluster_lifecycle.png"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can listen to cluster events by subscribing to their async sequence available on the cluster control object, like this:"}]},{"type":"codeListing","syntax":"swift","code":["for await event in system.cluster.events {","    switch event {","    case .snapshot(let membership):","        \/\/ handle a snapshot of the current state of the cluster, ","        \/\/ followed by any events that happen since","        break","    case .membershipChange(let change):","        \/\/ some change in the cluster membership ","        \/\/ (See Cluster Membership documentation)","        break","    case .reachabilityChange(let change):","        \/\/ some change in the reachability of cluster members,","        \/\/ e.g. a node became \"unreachable\"","        break","    case .leadershipChange(let change):","        \/\/ a new cluster leader has been detected","        break","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can refer to the specific events in their API documentation:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MembershipChange"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/ReachabilityChange"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/LeadershipChange"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another common pattern is to store a "},{"type":"codeVoice","code":"membership"},{"type":"text","text":" value and "},{"type":"codeVoice","code":"apply"},{"type":"text","text":" all later incoming objects to it."},{"type":"text","text":" "},{"type":"text","text":"As you "},{"type":"codeVoice","code":"apply"},{"type":"text","text":" these events, a change will be emitted signalling what changed, and you can react to it,"},{"type":"text","text":" "},{"type":"text","text":"or only observe the “current” status of the membership. This can be more precise than periodically polling the"},{"type":"text","text":" "},{"type":"codeVoice","code":"system.cluster.membership"},{"type":"text","text":" as that call only is a “snapshot” of the membership in a specific moment in time,"},{"type":"text","text":" "},{"type":"text","text":"and may miss nodes which appear for a short moment and are already removed from the membership when you’d check the "},{"type":"codeVoice","code":"system.cluster.membership"},{"type":"text","text":" "},{"type":"text","text":"the next time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following pattern will reliably always give you "},{"type":"emphasis","inlineContent":[{"type":"text","text":"all"}]},{"type":"text","text":" events that happened to affect the clusters’ membership,"},{"type":"text","text":" "},{"type":"text","text":"by applying all the incoming events one by one:"}]},{"type":"codeListing","syntax":"swift","code":["var membership = Cluster.Membership.empty","","for await event in system.cluster.events {","    if case .membershipChanged(let change) = event {","        guard change.node == system.cluster.uniqueNode else {","            continue","        }","        guard change.isUp else {","            continue ","        }","","        try membership.apply(event)","        system.log.info(\"Hooray, this node is [UP]! Event: \\(event), membership: \\(membership)\")","        return","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As an alternative to the general "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/apply(event:)"},{"type":"text","text":", which does not return details about the changes in membership the event caused,"},{"type":"text","text":" "},{"type":"text","text":"you can use the more specific "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/applyMembershipChange(_:)"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/applyLeadershipChange(_:)"},{"type":"text","text":", or "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/applyReachabilityChange(_:)"},{"type":"text","text":" in case you’d need this information."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership"},{"type":"text","text":" also offers a number of useful APIs to inspect the membership of the cluster, so familiarize yourself with its API when working with cluster membership."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A new async\/await API might be offered that automates such “await for some node to reach some state” in the future, refer to "},{"overridingTitleInlineContent":[{"type":"text","text":"#948"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-distributed-actors\/issues\/948","overridingTitle":"#948"},{"type":"text","text":" for more details."}]}]},{"anchor":"Cluster-Leadership","level":2,"type":"heading","text":"Cluster Leadership"},{"type":"paragraph","inlineContent":[{"type":"text","text":"TODO: document leadership and Leadership changes."}]},{"anchor":"Actor-Discovery:-Receptionist","level":2,"type":"heading","text":"Actor Discovery: Receptionist"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Discovering actors is an important aspect of distributed programming, as it is "},{"type":"emphasis","inlineContent":[{"type":"text","text":"the"}]},{"type":"text","text":" primary way we can discover actors on other nodes,"},{"type":"text","text":" "},{"type":"text","text":"and communicate with them."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Distributed actors are not automatically advertised in the cluster, and must opt-in into discovery by checking-in with the system’s local"},{"type":"text","text":" "},{"type":"text","text":"receptionist. This is because not all distributed actors need to necessarily be discovered by "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" other node in the cluster."},{"type":"text","text":" "},{"type":"text","text":"Some distributed actors may only be handed out after authenticating who is trying to access them (and then still, they may perform"},{"type":"text","text":" "},{"type":"text","text":"additional authentication for specific remote calls)."}]},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The receptionist pattern is called “receptionist”, because similar to a hotel, actors need to check-in at it in"},{"type":"text","text":" "},{"type":"text","text":"order to let others know they are available to meet now."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Checking-in with the receptionist is performed by calling "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/DistributedReceptionist\/checkIn(_:with:)"},{"type":"text","text":" and passing a"},{"type":"text","text":" "},{"type":"text","text":"specific key; The key is useful for when the same types of actor, may want to perform different roles. For example, you may"},{"type":"text","text":" "},{"type":"text","text":"have the same type of actor serve requests for different “teams”, and use the reception keys to identify"}]},{"type":"codeListing","syntax":"swift","code":["distributed actor Worker {","    typealias ActorSystem = ClusterSystem","    ","    distributed func work() { \/* ... *\/ }","}","","extension DistributedReception.Key {","    static var workers: DistributedReception.Key<Worker> {","        \"workers\"","    }","}","","\/\/ ------------","let worker = Worker()","\/\/ ------------","","system.receptionist.checkIn(worker, with: .workers) "]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The receptionist automatically watches checked-in actors, and removes them from the listing once they have been terminated."},{"type":"text","text":" "},{"type":"text","text":"Other actors which discover the actor, and want to be informed once the actor has terminated, should use the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Lifecycle"},{"type":"text","text":" APIs."}]},{"type":"aside","style":"warning","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"codeVoice","code":"DistributedReception.Key"},{"type":"text","text":"s are likely to be collapsed with "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ActorTag"},{"type":"text","text":" during the beta releases."},{"type":"text","text":" "},{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-distributed-actors\/issues\/950"}]}]},{"anchor":"Receptionist:-Listings","level":3,"type":"heading","text":"Receptionist: Listings"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The opposite side of using a receptionist, is actually obtaining a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/DistributedReceptionist\/listing(of:)"},{"type":"text","text":" of actors registered with a specific key."}]},{"type":"codeListing","syntax":"swift","code":["for await worker in await receptionist.listing(of: .workers) {","    try await worker.work() \/\/ message or store discovered workers","    ","    if enoughWorkers {","        return","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A typical pattern to use with listings is to create an unstructured task (using "},{"type":"codeVoice","code":"Task { ... }"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"and store it inside an actor that will be responsible for interacting with the discovered actors."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once that actor is deinitialized, that task should be cancelled as well, which we can do in its "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":", like this:"}]},{"type":"codeListing","syntax":"swift","code":["distributed actor Boss: LifecycleWatch { ","    var workers: Set<Weak<Worker>> = []","    ","    var listingTask: Task<Void, Never>?","    ","    func findWorkers() async {","        guard listingTask == nil else {","            actorSystem.log.info(\"Already looking for workers\")","            return","        }","","        listingTask = Task {","            for await worker in actorSystem.receptionist.listing(of: .workers) {","                workers.insert(worker)","            }","        }","    }","    ","    deinit {","        listingTask?.cancel()","    }","}"]},{"anchor":"Customizing-Remote-Calls","level":2,"type":"heading","text":"Customizing Remote Calls"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Remote calls are at the heart of what makes distributed actors actually distributed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A call made on a remote distributed actor reference, will cross network boundaries, and therefore may way due to"},{"type":"text","text":" "},{"type":"text","text":"network issues, message loss, serialization errors, or other reasons such as the recipient node crashing as it"},{"type":"text","text":" "},{"type":"text","text":"processes the message. Even replies to remote calls could sometimes fail being delivered, so you might need to"},{"type":"text","text":" "},{"type":"text","text":"design your distributed actors with idempotency (the resilience of a method being called more than once, e.g. due to a retry) in mind."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, to avoid “hanging” a remote caller forever on a suspended remote call as the recipient node fails to reply to it,"},{"type":"text","text":" "},{"type":"text","text":"for example because it (or the network itself), are currently unresponsive, remote calls have a default timeout configured,"},{"type":"text","text":" "},{"type":"text","text":"and if no reply is received within this duration, the call will fail with a "},{"type":"codeVoice","code":"RemoteCallError"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can configure the default timeout used by the cluster system during its initialization:"}]},{"type":"codeListing","syntax":"swift","code":["ClusterSystem() { settings in ","    settings.","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/distributedactors\/clustering"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Clustering","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Clustering multiple actor system instances into a single Distributed Actor System."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Clustering","role":"article","modules":[{"name":"DistributedActors"}]},"hierarchy":{"paths":[["doc:\/\/DistributedActors\/documentation\/DistributedActors"]]},"seeAlsoSections":[{"title":"Articles","identifiers":["doc:\/\/DistributedActors\/documentation\/DistributedActors\/Introduction","doc:\/\/DistributedActors\/documentation\/DistributedActors\/Lifecycle","doc:\/\/DistributedActors\/documentation\/DistributedActors\/Observability"],"generated":true}],"references":{"doc://DistributedActors/documentation/DistributedActors/ActorTag":{"role":"symbol","title":"ActorTag","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActorTag"}],"abstract":[{"type":"text","text":"Used to tag actor identities with additional information."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ActorTag","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActorTag"}],"url":"\/documentation\/distributedactors\/actortag"},"doc://DistributedActors/documentation/DistributedActors/Cluster/MemberStatus/joining":{"role":"symbol","title":"Cluster.MemberStatus.joining","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"joining"}],"abstract":[{"type":"text","text":"Describes a node which is connected to at least one other member in the cluster,"},{"type":"text","text":" "},{"type":"text","text":"it may want to serve some traffic, however should await the leader moving it to .up"},{"type":"text","text":" "},{"type":"text","text":"before it takes on serious work."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MemberStatus\/joining","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/cluster\/memberstatus\/joining"},"doc://DistributedActors/documentation/DistributedActors":{"role":"collection","title":"DistributedActors","abstract":[{"type":"text","text":"A peer-to-peer cluster actor system implementation for Swift."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors"},"doc://DistributedActors/documentation/DistributedActors/ClusterSystem":{"role":"symbol","title":"ClusterSystem","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ClusterSystem"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ClusterSystem"},{"type":"text","text":" is a confined space which runs and manages Actors."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterSystem","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ClusterSystem"}],"url":"\/documentation\/distributedactors\/clustersystem"},"doc://DistributedActors/documentation/DistributedActors/Cluster/Member":{"role":"symbol","title":"Cluster.Member","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Member"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Member"},{"type":"text","text":" is a node that is participating in a clustered system."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Member","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Member"}],"url":"\/documentation\/distributedactors\/cluster\/member"},"doc://DistributedActors/documentation/DistributedActors/Cluster/LeadershipChange":{"role":"symbol","title":"Cluster.LeadershipChange","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"LeadershipChange"}],"abstract":[{"type":"text","text":"Emitted when a change in leader is decided."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/LeadershipChange","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LeadershipChange"}],"url":"\/documentation\/distributedactors\/cluster\/leadershipchange"},"doc://DistributedActors/documentation/DistributedActors/Cluster/MembershipChange":{"role":"symbol","title":"Cluster.MembershipChange","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MembershipChange"}],"abstract":[{"type":"text","text":"Represents a change made to a "},{"type":"codeVoice","code":"Membership"},{"type":"text","text":", it can be received from gossip and shall be applied to local memberships,"},{"type":"text","text":" "},{"type":"text","text":"or may originate from local decisions (such as joining or downing)."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MembershipChange","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MembershipChange"}],"url":"\/documentation\/distributedactors\/cluster\/membershipchange"},"doc://DistributedActors/documentation/DistributedActors/DistributedReceptionist/listing(of:)":{"role":"symbol","title":"listing(of:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"listing"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Guest"},{"kind":"text","text":">("},{"kind":"externalParam","text":"of"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"DistributedReception","preciseIdentifier":"s:17DistributedActors0A9ReceptionO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Key","preciseIdentifier":"s:17DistributedActors0A9ReceptionO3KeyV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Guest"},{"kind":"text","text":">) "},{"kind":"keyword","text":"async"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"DistributedReception","preciseIdentifier":"s:17DistributedActors0A9ReceptionO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"GuestListing","preciseIdentifier":"s:17DistributedActors0A9ReceptionO12GuestListingV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Guest"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Returns a “listing” asynchronous sequence which will emit actor references,"},{"type":"text","text":" "},{"type":"text","text":"for every distributed actor that the receptionist discovers for the specific key."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/DistributedReceptionist\/listing(of:)","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/distributedactors\/distributedreceptionist\/listing(of:)"},"doc://DistributedActors/documentation/DistributedActors/Introduction":{"role":"article","title":"Introducing Distributed Actors","abstract":[{"type":"text","text":"A high-level introduction to distributed actor systems."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Introduction","kind":"article","type":"topic","url":"\/documentation\/distributedactors\/introduction"},"doc://DistributedActors/documentation/DistributedActors/Lifecycle":{"role":"article","title":"Lifecycle Monitoring","abstract":[{"type":"text","text":"Monitoring distributed actor lifecycles regardless of their location."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Lifecycle","kind":"article","type":"topic","url":"\/documentation\/distributedactors\/lifecycle"},"doc://DistributedActors/documentation/DistributedActors/DowningStrategy":{"role":"symbol","title":"DowningStrategy","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DowningStrategy"}],"abstract":[{"type":"text","text":"Allows implementing downing strategies, without having to re-implement and reinvent logging and subscription logic."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/DowningStrategy","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DowningStrategy"}],"url":"\/documentation\/distributedactors\/downingstrategy"},"doc://DistributedActors/documentation/DistributedActors/Cluster/Membership":{"role":"symbol","title":"Cluster.Membership","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Membership"}],"abstract":[{"type":"text","text":"Represents the set of members of this cluster."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Membership"}],"url":"\/documentation\/distributedactors\/cluster\/membership"},"doc://DistributedActors/documentation/DistributedActors/Observability":{"role":"article","title":"Observability","abstract":[{"type":"text","text":"The cluster system offers a number of built-in observability capabilities about the state of the cluster, as well as distributed actors it manages."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Observability","kind":"article","type":"topic","url":"\/documentation\/distributedactors\/observability"},"doc://DistributedActors/documentation/DistributedActors/Cluster/MemberStatus/down":{"role":"symbol","title":"Cluster.MemberStatus.down","fragments":[{"kind":"keyword","text":"case"},{"kind":"text","text":" "},{"kind":"identifier","text":"down"}],"abstract":[{"type":"text","text":"Describes a member believed to be “down”, either by announcement by the member itself, another member,"},{"type":"text","text":" "},{"type":"text","text":"a human operator, or an automatic failure detector. It is important to note that it is not a 100% guarantee"},{"type":"text","text":" "},{"type":"text","text":"that the member\/node process really is not running anymore, as detecting this with full confidence is not possible"},{"type":"text","text":" "},{"type":"text","text":"in distributed systems. It can be said however, that with as much confidence as the failure detector, or whichever"},{"type":"text","text":" "},{"type":"text","text":"mechanism triggered the "},{"type":"codeVoice","code":".down"},{"type":"text","text":" that node may indeed be down, or perhaps unresponsive (or too-slow to respond)"},{"type":"text","text":" "},{"type":"text","text":"that it shall be assumed as-if dead anyway."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/MemberStatus\/down","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/cluster\/memberstatus\/down"},"doc://DistributedActors/documentation/DistributedActors/Node":{"role":"symbol","title":"Node","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Node"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Node"},{"type":"text","text":" is a triplet of protocol, host and port that a node is bound to."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Node","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Node"}],"url":"\/documentation\/distributedactors\/node"},"https://github.com/apple/swift-distributed-actors/issues/948":{"title":"#948","titleInlineContent":[{"type":"text","text":"#948"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-distributed-actors\/issues\/948","url":"https:\/\/github.com\/apple\/swift-distributed-actors\/issues\/948"},"doc://DistributedActors/documentation/DistributedActors/UniqueNode":{"role":"symbol","title":"UniqueNode","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UniqueNode"}],"abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"unique"}]},{"type":"text","text":" node which includes also the node’s unique "},{"type":"codeVoice","code":"UID"},{"type":"text","text":" which is used to disambiguate"},{"type":"text","text":" "},{"type":"text","text":"multiple incarnations of a system on the same host\/port part – similar to how an "},{"type":"codeVoice","code":"ActorIncarnation"},{"type":"text","text":" "},{"type":"text","text":"is used on the per-actor level."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/UniqueNode","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UniqueNode"}],"url":"\/documentation\/distributedactors\/uniquenode"},"doc://DistributedActors/documentation/DistributedActors/Cluster/Membership/applyLeadershipChange(_:)":{"role":"symbol","title":"applyLeadershipChange(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"applyLeadershipChange"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Cluster","preciseIdentifier":"s:17DistributedActors7ClusterO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"LeadershipChange","preciseIdentifier":"s:17DistributedActors7ClusterO16LeadershipChangeV"},{"kind":"text","text":"?) "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Cluster","preciseIdentifier":"s:17DistributedActors7ClusterO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"LeadershipChange","preciseIdentifier":"s:17DistributedActors7ClusterO16LeadershipChangeV"},{"kind":"text","text":"?"}],"abstract":[{"type":"text","text":"Alias for "},{"type":"codeVoice","code":"applyLeadershipChange(to:)"}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/applyLeadershipChange(_:)","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/cluster\/membership\/applyleadershipchange(_:)"},"doc://DistributedActors/documentation/DistributedActors/Cluster/ReachabilityChange":{"role":"symbol","title":"Cluster.ReachabilityChange","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReachabilityChange"}],"abstract":[{"type":"text","text":"Emitted when the reachability of a member changes, as determined by a failure detector (e.g. "},{"type":"codeVoice","code":"SWIM"},{"type":"text","text":")."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/ReachabilityChange","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ReachabilityChange"}],"url":"\/documentation\/distributedactors\/cluster\/reachabilitychange"},"cluster_lifecycle.png":{"alt":"A diagram showing that a node joins as joining, then becomes up, and later on down or removed. It also shows the reachable and unreachable states on the side.","type":"image","identifier":"cluster_lifecycle.png","variants":[{"url":"\/images\/cluster_lifecycle.png","traits":["1x","light"]}]},"https://github.com/apple/swift-service-discovery":{"title":"swift-service-discovery","titleInlineContent":[{"type":"text","text":"swift-service-discovery"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-service-discovery","url":"https:\/\/github.com\/apple\/swift-service-discovery"},"doc://DistributedActors/documentation/DistributedActors/Cluster/Event":{"role":"symbol","title":"Cluster.Event","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"Event"}],"abstract":[{"type":"text","text":"Represents cluster events, most notably regarding membership and reachability of other members of the cluster."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Event","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Event"}],"url":"\/documentation\/distributedactors\/cluster\/event"},"doc://DistributedActors/documentation/DistributedActors/ClusterControl":{"role":"symbol","title":"ClusterControl","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ClusterControl"}],"abstract":[{"type":"text","text":"Allows controlling the cluster, e.g. by issuing join\/down commands, or subscribing to cluster events."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/ClusterControl","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ClusterControl"}],"url":"\/documentation\/distributedactors\/clustercontrol"},"doc://DistributedActors/documentation/DistributedActors/DistributedReceptionist/checkIn(_:with:)":{"role":"symbol","title":"checkIn(_:with:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"checkIn"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Guest"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"Guest"},{"kind":"text","text":", "},{"kind":"externalParam","text":"with"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"DistributedReception","preciseIdentifier":"s:17DistributedActors0A9ReceptionO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Key","preciseIdentifier":"s:17DistributedActors0A9ReceptionO3KeyV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Guest"},{"kind":"text","text":">) "},{"kind":"keyword","text":"async"}],"abstract":[{"type":"text","text":"Registers passed in distributed actor in the systems receptionist with given id."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/DistributedReceptionist\/checkIn(_:with:)","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/distributedactors\/distributedreceptionist\/checkin(_:with:)"},"doc://DistributedActors/documentation/DistributedActors/Cluster/Membership/apply(event:)":{"role":"symbol","title":"apply(event:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"apply"},{"kind":"text","text":"("},{"kind":"externalParam","text":"event"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Cluster","preciseIdentifier":"s:17DistributedActors7ClusterO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Event","preciseIdentifier":"s:17DistributedActors7ClusterO5EventO"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"}],"abstract":[{"type":"text","text":"Applies any kind of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Event"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"Membership"},{"type":"text","text":", modifying it appropriately."},{"type":"text","text":" "},{"type":"text","text":"This apply does not yield detailed information back about the type of change performed,"},{"type":"text","text":" "},{"type":"text","text":"and is useful as a catch-all to keep a "},{"type":"codeVoice","code":"Membership"},{"type":"text","text":" copy up-to-date, but without reacting on any specific transition."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/apply(event:)","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/cluster\/membership\/apply(event:)"},"doc://DistributedActors/documentation/DistributedActors/Cluster/Membership/applyMembershipChange(_:)":{"role":"symbol","title":"applyMembershipChange(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"applyMembershipChange"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Cluster","preciseIdentifier":"s:17DistributedActors7ClusterO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"MembershipChange","preciseIdentifier":"s:17DistributedActors7ClusterO16MembershipChangeV"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Cluster","preciseIdentifier":"s:17DistributedActors7ClusterO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"MembershipChange","preciseIdentifier":"s:17DistributedActors7ClusterO16MembershipChangeV"},{"kind":"text","text":"?"}],"abstract":[{"type":"text","text":"Interpret and apply passed in membership change as the appropriate join\/leave\/down action."}],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/applyMembershipChange(_:)","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/cluster\/membership\/applymembershipchange(_:)"},"https://github.com/apple/swift-distributed-actors/issues/950":{"title":"Make use of ActorTag rather than separate keys infra for reception #950","titleInlineContent":[{"type":"text","text":"Make use of ActorTag rather than separate keys infra for reception #950"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-distributed-actors\/issues\/950","url":"https:\/\/github.com\/apple\/swift-distributed-actors\/issues\/950"},"doc://DistributedActors/documentation/DistributedActors/Cluster/Membership/applyReachabilityChange(_:)":{"role":"symbol","title":"applyReachabilityChange(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"applyReachabilityChange"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Cluster","preciseIdentifier":"s:17DistributedActors7ClusterO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"ReachabilityChange","preciseIdentifier":"s:17DistributedActors7ClusterO18ReachabilityChangeV"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Cluster","preciseIdentifier":"s:17DistributedActors7ClusterO"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Member","preciseIdentifier":"s:17DistributedActors7ClusterO6MemberV"},{"kind":"text","text":"?"}],"abstract":[],"identifier":"doc:\/\/DistributedActors\/documentation\/DistributedActors\/Cluster\/Membership\/applyReachabilityChange(_:)","kind":"symbol","type":"topic","url":"\/documentation\/distributedactors\/cluster\/membership\/applyreachabilitychange(_:)"},"https://github.com/tuplestream/swift-k8s-service-discovery":{"title":"tuplestream\/swift-k8s-service-discovery","titleInlineContent":[{"type":"text","text":"tuplestream\/swift-k8s-service-discovery"}],"type":"link","identifier":"https:\/\/github.com\/tuplestream\/swift-k8s-service-discovery","url":"https:\/\/github.com\/tuplestream\/swift-k8s-service-discovery"}}}